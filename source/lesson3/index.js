var fs = require('fs');
var R = require('ramda');

const readF = path => fs.readFileSync(path, { encoding: 'utf-8' });

// 1. 首先我们读入两个文件的数据，并输出到控制台
R.pipe(
    R.map(readF),
    console.log
)(['./btc.csv', './eth.csv']);

// 控制台中发现我们读取的数据是这样的：
//   [
//     'Nov 05 2019\t9413.00\t9457.42\t9256.93\t9342.53\t26198609048\t168459778835\r' +
//       '\nNov 04 2019\t9235.61\t9505.05\t9191.49\t9412.61\t26170255634\t169706332936\r' +
//       '\nNov 03 2019\t9324.79\t9379.81\t9141.25\t9235.35\t21132220847\t166495319475\r' +
//       '\n',
//     'Nov 05 2019\t9413.00\t9457.42\t9256.93\t9342.53\t26198609048\t168459778835\r' +
//       '\nNov 04 2019\t9235.61\t9505.05\t9191.49\t9412.61\t26170255634\t169706332936\r' +
//       '\nNov 03 2019\t9324.79\t9379.81\t9141.25\t9235.35\t21132220847\t166495319475\r' +
//       '\n'
//   ]

// 挺乱的一组数据，我们接下去逐一处理， 首先先分割下\r\n吧
// 2. 分割
R.pipe(
    R.map(readF),
    R.map(R.split('\r\n')), // 注意哦， 这边要用map包裹split，因为是处理数组哦
    console.log
)(['./btc.csv', './eth.csv']);

// 现在输出是这样了， 总算有点样子了
//   [
//     [    // 这边是btc.csv里面的数据
//       'Nov 05 2019\t9413.00\t9457.42\t9256.93\t9342.53\t26198609048\t168459778835',
//       'Nov 04 2019\t9235.61\t9505.05\t9191.49\t9412.61\t26170255634\t169706332936',
//       'Nov 03 2019\t9324.79\t9379.81\t9141.25\t9235.35\t21132220847\t166495319475',
//       ''
//     ],
//     [    // 这边是eth.csv里面的数据
//       'Nov 05 2019\t9413.00\t9457.42\t9256.93\t9342.53\t26198609048\t168459778835',
//       'Nov 04 2019\t9235.61\t9505.05\t9191.49\t9412.61\t26170255634\t169706332936',
//       'Nov 03 2019\t9324.79\t9379.81\t9141.25\t9235.35\t21132220847\t166495319475',
//       ''
//     ]
//   ]

// 大家发现上面最后还多了个空行，所以我们还要把这个空行去掉
R.pipe(
    R.map(readF),
    R.map(R.split('\r\n')),
    R.map(R.dropLast(1)),
    console.log
)(['./btc.csv', './eth.csv']);

// 3. 好了，搞定！ 接下去我们要开始处理列了，把每一列分割出来
R.pipe(
    R.map(readF),
    R.map(R.split('\r\n')),
    R.map(R.dropLast(1)),
    R.map(R.map(R.split('\t'))),    // 注意哦，这边有两个map哦， 因为已经是二维数组了
    console.log
)(['./btc.csv', './eth.csv']);

// 这下差不多了，每一列也有了
// [
//     [
//       [
//         'Nov 05 2019',
//         '9413.00',
//         '9457.42',
//         '9256.93',
//         '9342.53',
//         '26198609048',
//         '168459778835'
//       ],
//       ... 很多省略
//     ],
//     [
//       [
//         'Nov 05 2019',
//         '9413.00',
//         '9457.42',
//         '9256.93',
//         '9342.53',
//         '26198609048',
//         '168459778835'
//       ],
//       ... 很多省略
//     ]
//   ]

// 4. 可能我们只关心前面两列的数据，其他数据不想要了, 那我们就再加一句
R.pipe(
    R.map(readF),
    R.map(R.split('\r\n')),
    R.map(R.dropLast(1)),
    R.map(R.map(R.split('\t'))),
    R.map(R.map(R.take(2))),    // 只取每个数组的前两个元素
    console.log
)(['./btc.csv', './eth.csv']);

//   [
//     [
//       [ 'Nov 05 2019', '9413.00' ],
//       [ 'Nov 04 2019', '9235.61' ],
//       [ 'Nov 03 2019', '9324.79' ]
//     ],
//     [
//       [ 'Nov 05 2019', '9413.00' ],
//       [ 'Nov 04 2019', '9235.61' ],
//       [ 'Nov 03 2019', '9324.79' ]
//     ]
//   ]
